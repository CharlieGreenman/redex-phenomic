{"type":"published","id":"re-respect","name":"re-respect","version":"0.4.3","description":"[![Build Status](https://travis-ci.org/PeteProgrammer/respect.svg?branch=master)](https://travis-ci.org/PeteProgrammer/respect)","license":"MIT","keywords":["test","bucklescript","testing","tdd","reason","bdd"],"body":"# ReSpect\n\n[![Build Status](https://travis-ci.org/PeteProgrammer/respect.svg?branch=master)](https://travis-ci.org/PeteProgrammer/respect)\n\nThis is an RSpec inspired test framework for ReasonML/OCaml/Bucklescript. The\nrunner uses raw javascript code, so it will only run in node environments at the moment.\n\nI base this on a lot of experience I gained from a similar project for F#, FSpec.\n\nThis project is still in a very early stage, so use at your own risk.\n\n## Latest changes\n\n### 0.4.0 - 0.4.3\n\n * Added `Ctx.tryGet` - Returns `None` if no entry with the specified key exists\n     in the context data.\n * Added Respect.Ctx module as alias for TestContext\n * TestContext.don function to help accept a done callback from setup functions\n * Refactor: Test context is now represented by an object instead of a mutable\n     record. But the TestContext module still has functions for operating on the\n     actual context, so existing code should be compatible.\n * Testcontext subject: The subject is a function that evaluates to an actual\n     value when requested. The function receives the test context as input. You\n     can assign the subject in a parent group, and modify the context in a child\n     group.\n * TextContext.map: Allows you to easily modify objects in the context.\n\n### 0.3.0\n\n * Breaking change: In order to get better error messages when match fails, the\n     MatchFailure constructor now takes two args, the actual object, and the\n     expected object of the failed matcher.\n\nPreviously when testing async code, I could get messages like this\n```\nExpected: [ [\"john.doe@example.com\"], ...]\nActual: [ [Function] ]\n```\nWhich wasn't helpful in finding the bug.\n\n## TODO\n\n * \"Finalize\" DSL for building test suites.\n * Determine whether or not to allow mutation of `TestContext`. This worked well\n     in F#/FSpec, but we don't have runtime type checking in Reason/Bucklescript.\n * Finalize assertion framework.\n * Nicer test output when running.\n * Nicer test output when assertions fail.\n * Internally, figure out how to report progresss.\n * More flexible runner, e.g. configurable location of test files\n * âœ“ Handle async timeout to avoid hanging when async tests don't call back\n * Make timeout configurable through example metadata.\n\nAlthough, I had learned from many mistakes when building FSpec, there are some\nproblems that demand different solutions in Reason/Bucklescript. Async support\nin particular.\n\n## Installation\n\nThis guide will help you get `Respect` and having a test-watcher setup.\n_Respect_ in itself does not implement test-watcher functionality, but it is\neasily added with the _nodemon_ package.\n\n### Basic installation\n\nFirst, add _respect_, the npm package is named \"re-respect\"\n\n```\nnpm install --save-dev re-respect\n```\n\nAs this is a package with Reason code, you need to add a reference to the\npackage in the _bsconfig.json_ file, as well.\n\nYou also need to add a _tests_ folder to contain the tests. At this early time\nof writing, the only place that Respect searches for tests files is in the\n_tests_ folder, so be sure that is the exact name of the folder.\n\n```\n\"files\": [\n  {\"dir\": \"src\"},\n  {\"dir\": \"tests\",\n   \"type\": \"dev\" }\n],\n\"bs-dev-dependencies\": [\n  \"re-respect\"\n]\n```\n\nCreate a skeleton test, \"./tests/tests.re\":\n\n```\nopen Respect.Dsl;\n\ndescribe \"My first test\" [\n  it \"runs\" (fun _ => {()})\n] |> register\n```\n\nThe `register` call is necessary at this early stage, it adds the specs to one\nglobal test group.\n\nNow, let's add a test target to _package.json_\n\n```\n\"scripts\": {\n   ...\n   \"test\": \"respect\"\n}\n```\n\nAnd now, you can run the tests with `npm run test`\n\n### Adding test watcher functionality\n\nThe npm package _nodemon_ can trigger running _.js_ files when the file system\nchanges. We can use this to implement filesystem watcher functionality. First\ninstall the package\n\n```\nnpm install --save-dev nodemon\n```\n\nAnd then add a script to the _package.json_ file\n\n```\n  \"scripts\": {\n    ...\n    \"test:watch\": \"nodemon node_modules/re-respect/bin/respect\"\n  }\n```\n\nAnd now, you can have the tests run automatically when a _.js_ file changes\nwith the command `npm run test:watch`. Of course, when you edit reason source\nfiles, that will not trigger a test run, so you need to run `npm run watch` in a\ndifferent terminal.\n\n### Optionally, create a _dev_ task\n\nIn the previous section, you had to run two watchers in two separate terminals\nin order to have full watcher implementation. We can create an npm script that\ndoes both of these tasks with the help of the npm package _npm-run-all_, which\nallows parallel execution of multiple scripts.\n\n```\nnpm install --save-dev npm-run-all\n```\n\nIn the _package.json_ file, add a new script:\n\n```\n  \"scripts\": {\n    ...\n    \"dev\": \"run-p watch test:watch\"\n  }\n```\n\nThe command `run-p` is part of _npm-run-all_, and it runs the two scripts in\nparallel.\n\nNow you can run `npm run dev` in one terminal, and it will compile reason files,\nand run tests, as files are written on disk.\n\n## Syntax\n\nInstead of using mutating nested function calls, _Respect_ uses immutable data\nstructures for building up the test context and tests. Therefore, the\n`desribe`-operation takes nested operations in a list.\n\n```\nregister(\n  describe \"Parent context\" [\n    it \"has some test\" (fun _ =>\n      ...\n    )\n    it \"has some test\" (fun _ =>\n      ...\n    )\n\n    describe \"Child context\" [\n      it \"has more tests\" (fun _ =>\n        ...\n      )\n    ]\n  ])\n```\n\nThe only mutating construct here is the function `register` which adds the group\nof examples to an implicit root group.\n\n### Pending tests\n\nOften it is useful to write pending tests, small skeleton desrciptions of\nfunctionality you need to implement. This can turn the test framework into a\nsmall todo list:\n\n```\ndescribe(\"Register user\", [\n  pending(\"Returns Ok(user) if registration succeeded\"),\n  pending(\"Returns Error(DuplicateEmail) if email already registered\"),\n]) |> register\n```\n\nPending tests will not result in failure when running the tests.\n\n## Async tests\n\nAsync support is currently best implemented by opening `Respect.Dsl.Async`.\n\nI believe that this will be in time be the the only \"official\" Dsl to end with,\nbut maybe with helper functions to write sync examples if you need to.\n\n```\nopen Respect.Dsl.Async;\n\ndescribe \"Parent context\" [\n  it \"has an async test\" (fun _ don => {\n    if (success) {\n      don ();\n    }else {\n      don err::\"Error\" ();\n    }\n  })\n] |> register;\n```\n\nThere is currently async matcher support through the function `shoulda`\n(should-async). The function has the signature:\n\n```\n(matcher : matcher 'a 'b) => (actual : 'a) => (cb : doneCallback) => unit\n```\n\nThis signature plays nicely with the callback allowing you to write tests like\nthis:\n\n```\ndescribe \"Register User\" [\n  describe \"Posting valid user\" [\n    it \"creates a user\" (fun _ => {\n      createValidInput ()\n        |> UserFeature.registerUser\n        |> shoulda asyncSucceed\n    })\n  ]\n] |> register\n```\n\nThis is a bit cryptic but I'll try to explain\n\n* Our test function didn't explicitly specify a done callback\n* We didn't pass a done callback to to the `shoulda` function either. This makes\n    the result of the `shoulda` function another function, which takes a done\n    callback.\n* So the result of our test function is the function returned by `should`, the\n    one that takes done callback. Thus our test function has the exact shape that `it` expects.\n* The `registerUser` is an async function that expects a callback that we didn't supply.\n* The asyncSucceed takes an async function as argument and supplies the right\n    callback that binds it to the done callback.\n\nThis doesn't play nice however, if you want to have multiple assertions in the\nsame test :(\n\nIt will come.\n\nPlease be aware that the matcher syntax is likely to change, but I will try\nto keep backward compatibility by moving alternate matcher framework into separate\nmodules.\n\n## Matchers (breaking change in version 0.2)\n\nThe matchers framework is based on these types:\n\n```\ntype matchResult('t) =\n  | MatchSuccess('t)\n  | MatchFailure(Obj.t);\n\ntype matcher('a, 'b) = 'a => (matchResult('b) => unit) => unit;\n\nexception MatchFailedException(string);\n```\n\nSo a matcher takes an actual value and provides a matchresult asyncrounously\nthrough a callback. Matchers that evaluate synchronously can use these helper\nfunctions\n\n```\nlet matchSuccess = (a) => cb => cb(MatchSuccess(a));\nlet matchFailure = (a) => cb => cb(MatchFailure(a |> Obj.repr));\n```\n\nSo if we look at the `equal` match constructor:\n\n```\nlet equal = (expected, actual) =>\n  actual == expected ? matchSuccess(actual) : matchFailure(expected);\n```\n\nSo it takes an expected value and returns a matcher based on this.\n\n## Test Metadata\n\nYou can add metadata to a group or an example. And if you have metadata on a\nparent group, you can override it in a child group. The metadata is added using\nthe strange looking _**>_ operator (I chose this because the _*_ makes it right\nassociative, which I need in order to avoid parenthesis hell, and the _>_ helps\nindicating that the metadata binds to the group/example to come.\n\nThe interesting thing is that the metadata is initialized before the example\nstarts executing, which means that metadata specified on an example can effect\nthe setup code executed in a parent group. The following example shows how:\n\n```\nopen Respect.Dsl.Async;\n\ndescribe \"Register user\" [\n  beforeEach (fun ctx don => {\n    ctx |> TestContext.get \"userName\"\n    |> /* do something interesting with the user */\n    don()\n  }),\n\n  (\"userName\", \"johndoe\") **>\n  describe \"A valid user name was entered\" [\n    it \"Correctly registers the user\" (fun ctx don => {\n       ...\n       don\n    })\n  ],\n\n  (\"userName\", \"!@#$\") **>\n  describe \"An invalid user name was entered\" [\n    it \"Returns a sensible error message\" (fun ctx don => {\n       ...\n       don ()\n    })\n  ]\n] |> register\n```\n\n### Composing Matchers\n\nMatchers can be composed using the \"fish\" operator `>=>`, so a `matcher 'a 'b`\ncan be composed with a `matcher 'b 'c` into a `matcher 'a 'c`.\n\nThis can be particularly useful when the value passed with the success is\ndifferent from the actual value passed to the matcher. Here is an example from a\npiece of production code I am working on:\n\n```\n/* General types to handle errors and async code */\ntype result 'a 'b =\n  | Ok 'a\n  | Error 'b;\ntype async 'a = ('a => unit) => unit;\ntype asyncResult 'a 'b = async (result 'a 'b);\n\n/* Specific error types returned by repository layer */\ntype databaseError 'id =\n| DocumentNotFound string 'id\n| MongoErr MongoError.t;\n\n/* This is a matcher that verifies that an async function fails. \"actual\" is a\nfunction that takes a result callback */\nlet asyncFail actual => {\n  AsyncMatchResult (fun cb => {\n    actual\n      |> AsyncResult.run (fun\n      | Error y => cb (MatchSuccess y)\n      | Ok y => cb (MatchFailure (Obj.repr y)));\n      });\n};\n```\n\nThe interesting thing is that the `asyncFail` matcher passes the error to the\n`MatchResult` constructor, to be used by a new matcher. In this tests we compose\nit with a new matcher that verifies that we actually get the expected error.\n\n```\ndescribe \"UserRepository\" [\n    describe \"findById\" [\n      describe \"record doesn't exist\" [\n        it \"returns DocumentNotFound\" (fun _ => {\n          let id = \"dummy\";\n          UserRepository.getById id\n            |> shoulda (UserFeature_test.asyncFail >=> (equal (DocumentNotFound \"users\" id)))\n        })\n      ]\n    ]\n  ],\n] |> register;\n```\n\nThe operator supports combining sync and async matchers as you like - but they\nare not properly tested in the framework. Only the above case async>=>sync\nmatcher has been tested in the wild.","analyzed":"2017-12-21T11:59:43.498Z","updated":"2017-12-21T11:59:43.498Z","stars":11,"score":0.6170097302045341,"quality":0.8231800255322599,"popularity":0.05730206441387497,"maintenance":1,"homepageUrl":"https://github.com/PeteProgrammer/respect#readme","repositoryUrl":"https://github.com/PeteProgrammer/respect","npmUrl":"https://www.npmjs.com/package/re-respect","issuesUrl":"https://github.com/PeteProgrammer/respect/issues","docsUrl":null}